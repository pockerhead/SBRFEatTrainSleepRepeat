//
//  VKAuthScreenPresenter.m
//  EatTrainSleepRepeat
//
//  Created pockerhead on 18/05/2019.
//  Copyright © 2019 pockerhead. All rights reserved.
//
//  Template generated by Balashov Artem @pockerhead
//

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#import "VKAuthScreenPresenter.h"
#import "VKAuthScreenProtocols.h"
#import "KeychainService.h"

@interface VKAuthScreenPresenter () <VKAuthScreenPresenterInterface>
@property (strong, nonatomic) NSObject<VKAuthScreenWireframeInterface>* router;
@end

@implementation VKAuthScreenPresenter

- (instancetype)initWithView:(NSObject<VKAuthScreenView>*)view router:(NSObject<VKAuthScreenWireframeInterface>*)router {
    self = [super init];
    if (self) {
        self.view = view;
        self.router = router;
    }
    return self;
}

- (void)viewDidAppear {
    //Default implementation
}

- (void)viewDidDissappear {
    //Default implementation
}

- (void)viewDidLoad {
    NSString *authLink = [NSString stringWithFormat:@"https://oauth.vk.com/authorize?client_id=%@&display=mobile&redirect_uri=http://api.vk.com/blank.html&scope=friends&response_type=token&v=5.95&state=123456", @"6988476"];
    NSURL *url = [NSURL URLWithString:authLink];
    [self.view displayURL:url];
}

- (void)viewWillAppear {
    //Default implementation
}

- (void)viewWillDissappear {
    //Default implementation
}

- (void)didFinishLoadWithURL:(nonnull NSURL *)url {
    if ([url.absoluteString containsString:@"access_token"]) {
        NSDictionary *query = [self queryFromURL:url];
        NSString *token = [query objectForKey:@"access_token"];
        NSString *userID = [query objectForKey:@"user_id"];
        if (token && userID) {
            [KeychainService saveObject:token forKey:authTokenKey];
            [KeychainService saveObject:userID forKey:userIDKey];
            [self.view displaySuccesfullText:@"Вы успешно авторизованы!"];
        } else {
            ErrorDTO *error = [[ErrorDTO alloc] initWithTitle:nil message:@"Произошла ошибка, повторите позже..."];
            [self.view displayError:error];
        }
        
    } else if ([url.absoluteString containsString:@"error_description"]) {
        NSDictionary *query = [self queryFromURL:url];
        NSString *err = [query objectForKey:@"error_description"];
        if (err) {
            ErrorDTO *error = [[ErrorDTO alloc] initWithTitle:nil message:err];
            [self.view displayError:error];
        } else {
            ErrorDTO *error = [[ErrorDTO alloc] initWithTitle:nil message:@"Произошла ошибка, повторите позже..."];
            [self.view displayError:error];
        }
    }
}

- (void)didSelectDismissButton
{
    [self.router navigateToDismiss];
}

- (NSDictionary <NSString *, NSString *> *)queryFromURL:(NSURL *)url
{
    NSURLComponents *components = [NSURLComponents componentsWithString:url.absoluteString];
    NSString *fragment = components.fragment;
    NSMutableDictionary *queryStringDictionary = [[NSMutableDictionary alloc] init];
    NSArray *queryArray = [fragment componentsSeparatedByString:@"&"];
    for (NSString *keyValuePair in queryArray)
    {
        NSArray *pairComponents = [keyValuePair componentsSeparatedByString:@"="];
        NSString *key = [[pairComponents firstObject] stringByRemovingPercentEncoding];
        NSString *value = [[pairComponents lastObject] stringByRemovingPercentEncoding];
        
        [queryStringDictionary setObject:value forKey:key];
    }
    return queryStringDictionary;
}

@end
